from __future__ import annotations

import hashlib
import logging
import subprocess
import threading
from dataclasses import dataclass
from pathlib import Path
from typing import Dict

from .config import Settings
from .models import ProxyEndpoint

logger = logging.getLogger(__name__)


@dataclass
class GliderHandle:
    endpoint_id: str
    process: subprocess.Popen | None
    config_path: Path
    config_hash: str

    def is_alive(self) -> bool:
        return self.process is not None and self.process.poll() is None

    def stop(self) -> None:
        if not self.process:
            return
        try:
            self.process.terminate()
            self.process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            self.process.kill()
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Failed to stop glider process %s: %s", self.endpoint_id, exc)
        finally:
            self.process = None


class GliderManager:
    """Manages per-endpoint glider processes."""

    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self._handles: Dict[str, GliderHandle] = {}
        self._lock = threading.RLock()

    def _build_config(self, endpoint: ProxyEndpoint, backend_uri: str) -> str:
        protocol = endpoint.protocol.lower()
        host = (endpoint.host or "").strip()
        if host in {"", "0.0.0.0"}:
            listen_host = "0.0.0.0"
        elif host in {"::", "[::]"}:
            listen_host = "[::]"
        else:
            listen_host = host
        if listen_host.startswith("[") and listen_host.endswith("]"):
            formatted_host = listen_host
        elif ":" in listen_host:
            formatted_host = f"[{listen_host}]"
        else:
            formatted_host = listen_host

        if protocol == "socks5":
            listen = f"{formatted_host}:{endpoint.port}"
        else:
            scheme = "http"
            listen = f"{scheme}://{formatted_host}:{endpoint.port}"

        lines = [
            "# Auto-generated by proxychain",
            "verbose=true",
            f"listen={listen}",
            f"strategy={self.settings.glider_strategy}",
        ]
        if self.settings.health_check_url:
            interval = max(1, self.settings.glider_check_interval)
            lines.append(f"check={self.settings.health_check_url}")
            lines.append(f"checkinterval={interval}")
        lines.append(f"forward={backend_uri}")
        return "\n".join(lines) + "\n"

    def ensure(self, endpoint: ProxyEndpoint, backend_uri: str) -> bool:
        if not self.settings.enable_glider:
            return False
        binary = self.settings.glider_binary
        if not binary.exists():
            logger.warning("Glider binary not found at %s; endpoint %s disabled", binary, endpoint.id)
            return False

        config_content = self._build_config(endpoint, backend_uri)
        config_hash = hashlib.sha256(config_content.encode("utf-8")).hexdigest()
        config_path = self.settings.glider_config_dir / f"{endpoint.id}.conf"

        with self._lock:
            handle = self._handles.get(endpoint.id)
            if handle and not handle.is_alive():
                logger.info("Glider endpoint %s is not running; removing stale handle", endpoint.id)
                self._handles.pop(endpoint.id, None)
                handle = None
            if handle and handle.config_hash != config_hash:
                logger.info("Config changed for endpoint %s; restarting glider", endpoint.id)
                if handle.is_alive():
                    handle.stop()
                self._handles.pop(endpoint.id, None)
                handle = None
            if handle and handle.is_alive():
                # Config unchanged and process alive
                return True

            config_path.parent.mkdir(parents=True, exist_ok=True)
            config_path.write_text(config_content, encoding="utf-8")

            try:
                process = subprocess.Popen(
                    [str(binary), "-config", str(config_path)],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
            except FileNotFoundError:
                logger.warning("Glider binary %s not executable; endpoint %s disabled", binary, endpoint.id)
                return False
            except Exception as exc:  # pragma: no cover - defensive
                logger.error("Failed to start glider for %s: %s", endpoint.id, exc)
                return False

            try:
                process.wait(timeout=0.01)
            except subprocess.TimeoutExpired:
                pass
            else:
                logger.error(
                    "Glider exited immediately for endpoint %s with return code %s",
                    endpoint.id,
                    process.returncode,
                )
                return False

            handle = GliderHandle(
                endpoint_id=endpoint.id,
                process=process,
                config_path=config_path,
                config_hash=config_hash,
            )
            self._handles[endpoint.id] = handle
            logger.info(
                "Started glider endpoint %s (%s:%s)",
                endpoint.id,
                endpoint.protocol,
                endpoint.port,
            )
            return True

    def cleanup(self, active_endpoint_ids: set[str]) -> None:
        with self._lock:
            for endpoint_id in list(self._handles.keys()):
                if endpoint_id in active_endpoint_ids:
                    continue
                handle = self._handles.pop(endpoint_id, None)
                if handle:
                    logger.info("Stopping glider endpoint %s", endpoint_id)
                    handle.stop()
                    try:
                        handle.config_path.unlink(missing_ok=True)
                    except AttributeError:
                        if handle.config_path.exists():  # pragma: no cover
                            handle.config_path.unlink()

    def stop_all(self) -> None:
        with self._lock:
            for endpoint_id, handle in list(self._handles.items()):
                logger.info("Stopping glider endpoint %s", endpoint_id)
                handle.stop()
                try:
                    handle.config_path.unlink(missing_ok=True)
                except AttributeError:
                    if handle.config_path.exists():
                        handle.config_path.unlink()
            self._handles.clear()

    def status(self) -> dict:
        with self._lock:
            return {
                endpoint_id: {
                    "alive": handle.is_alive(),
                    "config": str(handle.config_path),
                }
                for endpoint_id, handle in self._handles.items()
            }
