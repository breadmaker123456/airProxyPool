from __future__ import annotations

import hashlib
import logging
import re
import subprocess
import threading
from dataclasses import dataclass
from pathlib import Path
from typing import Dict

from .config import Settings
from .models import ProxyEndpoint

logger = logging.getLogger(__name__)


_FILENAME_SANITIZE_PATTERN = re.compile(r"[^A-Za-z0-9._-]")


@dataclass
class GliderHandle:
    endpoint_id: str
    process: subprocess.Popen | None
    config_path: Path
    config_hash: str
    log_thread: threading.Thread | None = None

    def is_alive(self) -> bool:
        return self.process is not None and self.process.poll() is None

    def stop(self) -> None:
        if not self.process:
            return
        try:
            self.process.terminate()
            self.process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            self.process.kill()
        except Exception as exc:  # pragma: no cover - defensive
            logger.warning("Failed to stop glider process %s: %s", self.endpoint_id, exc)
        finally:
            self.process = None
            if self.log_thread and self.log_thread.is_alive():
                self.log_thread.join(timeout=1)


class GliderManager:
    """Manages per-endpoint glider processes."""

    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self._handles: Dict[str, GliderHandle] = {}
        self._lock = threading.RLock()

    def _log_glider_output(self, endpoint_id: str, process: subprocess.Popen) -> None:
        """Read glider process output and log it."""
        try:
            for line in iter(process.stdout.readline, ""):
                if not line:
                    break
                line = line.rstrip()
                if line:
                    logger.info("glider[%s]: %s", endpoint_id[:8], line)
        except Exception as exc:
            logger.debug("Error reading glider output for %s: %s", endpoint_id, exc)

    def _config_filename(self, endpoint_id: str) -> str:
        digest = hashlib.sha1(endpoint_id.encode("utf-8")).hexdigest()[:8]
        safe = _FILENAME_SANITIZE_PATTERN.sub("_", endpoint_id).strip("._-")
        if len(safe) > 48:
            safe = safe[:48]
        if not safe:
            safe = digest
        return f"{safe}-{digest}.conf"

    def _build_config(self, endpoint: ProxyEndpoint, backend_uri: str) -> str:
        protocol = endpoint.protocol.lower()
        host = (endpoint.host or "").strip()
        if host in {"", "0.0.0.0"}:
            listen_host = "0.0.0.0"
        elif host in {"::", "[::]"}:
            listen_host = "[::]"
        else:
            listen_host = host
        if listen_host.startswith("[") and listen_host.endswith("]"):
            formatted_host = listen_host
        elif ":" in listen_host:
            formatted_host = f"[{listen_host}]"
        else:
            formatted_host = listen_host

        if protocol == "socks5":
            listen = f"socks5://{formatted_host}:{endpoint.port}"
        else:
            scheme = "http"
            listen = f"{scheme}://{formatted_host}:{endpoint.port}"

        dial_timeout = max(1, self.settings.glider_dial_timeout)
        relay_timeout = max(1, self.settings.glider_relay_timeout) if self.settings.glider_relay_timeout > 0 else 0
        max_failures = max(1, self.settings.glider_max_failures)
        
        lines = [
            "# Auto-generated by proxychain",
            "verbose=true",
            f"listen={listen}",
            f"strategy={self.settings.glider_strategy}",
            f"dialtimeout={dial_timeout}",
            f"maxfailures={max_failures}",
        ]
        if relay_timeout > 0:
            lines.append(f"relaytimeout={relay_timeout}")
        if self.settings.health_check_url:
            interval = max(1, self.settings.glider_check_interval)
            check_timeout = max(1, self.settings.glider_check_timeout)
            lines.append(f"check={self.settings.health_check_url}")
            lines.append(f"checkinterval={interval}")
            lines.append(f"checktimeout={check_timeout}")
        lines.append(f"forward={backend_uri}")
        return "\n".join(lines) + "\n"

    def ensure(self, endpoint: ProxyEndpoint, backend_uri: str) -> bool:
        if not self.settings.enable_glider:
            return False
        binary = self.settings.glider_binary
        if not binary.exists():
            logger.warning("Glider binary not found at %s; endpoint %s disabled", binary, endpoint.id)
            return False

        config_content = self._build_config(endpoint, backend_uri)
        config_hash = hashlib.sha256(config_content.encode("utf-8")).hexdigest()
        config_filename = self._config_filename(endpoint.id)
        config_path = self.settings.glider_config_dir / config_filename

        previous_config_path: Path | None = None
        started = False

        with self._lock:
            handle = self._handles.get(endpoint.id)
            if handle:
                if not handle.is_alive():
                    logger.info("Glider endpoint %s is not running; removing stale handle", endpoint.id)
                    previous_config_path = handle.config_path
                    self._handles.pop(endpoint.id, None)
                    handle = None
                elif handle.config_path != config_path or handle.config_hash != config_hash:
                    reason = "configuration"
                    if handle.config_path != config_path and handle.config_hash == config_hash:
                        reason = "configuration path"
                    logger.info("Config changed for endpoint %s (%s); restarting glider", endpoint.id, reason)
                    previous_config_path = handle.config_path
                    if handle.is_alive():
                        handle.stop()
                    self._handles.pop(endpoint.id, None)
                    handle = None
                else:
                    return True

            try:
                config_path.parent.mkdir(parents=True, exist_ok=True)
                config_path.write_text(config_content, encoding="utf-8")
                logger.debug("Wrote glider config for %s to %s:\n%s", endpoint.id, config_path, config_content)
            except OSError as exc:
                logger.error("Failed to write glider config for %s: %s", endpoint.id, exc)
                return False

            try:
                process = subprocess.Popen(
                    [str(binary), "-config", str(config_path)],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    universal_newlines=True,
                    bufsize=1,
                )
            except FileNotFoundError:
                logger.warning("Glider binary %s not executable; endpoint %s disabled", binary, endpoint.id)
                try:
                    config_path.unlink(missing_ok=True)
                except OSError:
                    pass
                return False
            except Exception as exc:  # pragma: no cover - defensive
                logger.error("Failed to start glider for %s: %s", endpoint.id, exc)
                try:
                    config_path.unlink(missing_ok=True)
                except OSError:
                    pass
                return False

            try:
                process.wait(timeout=0.01)
            except subprocess.TimeoutExpired:
                pass
            else:
                logger.error(
                    "Glider exited immediately for endpoint %s with return code %s",
                    endpoint.id,
                    process.returncode,
                )
                try:
                    config_path.unlink(missing_ok=True)
                except OSError:
                    pass
                return False

            log_thread = threading.Thread(
                target=self._log_glider_output,
                args=(endpoint.id, process),
                daemon=True,
                name=f"glider-log-{endpoint.id[:8]}",
            )
            log_thread.start()

            handle = GliderHandle(
                endpoint_id=endpoint.id,
                process=process,
                config_path=config_path,
                config_hash=config_hash,
                log_thread=log_thread,
            )
            self._handles[endpoint.id] = handle
            logger.info(
                "Started glider endpoint %s (%s:%s)",
                endpoint.id,
                endpoint.protocol,
                endpoint.port,
            )
            started = True

        if previous_config_path and previous_config_path != config_path:
            try:
                previous_config_path.unlink(missing_ok=True)
            except AttributeError:
                if previous_config_path.exists():  # pragma: no cover
                    previous_config_path.unlink()
            except OSError:  # pragma: no cover - best effort cleanup
                logger.debug("Unable to remove stale glider config %s", previous_config_path)

        legacy_path = self.settings.glider_config_dir / f"{endpoint.id}.conf"
        if legacy_path != config_path:
            try:
                legacy_path.unlink(missing_ok=True)
            except (AttributeError, OSError):  # pragma: no cover - best effort cleanup
                pass

        return started

    def cleanup(self, active_endpoint_ids: set[str]) -> None:
        with self._lock:
            for endpoint_id in list(self._handles.keys()):
                if endpoint_id in active_endpoint_ids:
                    continue
                handle = self._handles.pop(endpoint_id, None)
                if handle:
                    logger.info("Stopping glider endpoint %s", endpoint_id)
                    handle.stop()
                    try:
                        handle.config_path.unlink(missing_ok=True)
                    except AttributeError:
                        if handle.config_path.exists():  # pragma: no cover
                            handle.config_path.unlink()

    def stop_all(self) -> None:
        with self._lock:
            for endpoint_id, handle in list(self._handles.items()):
                logger.info("Stopping glider endpoint %s", endpoint_id)
                handle.stop()
                try:
                    handle.config_path.unlink(missing_ok=True)
                except AttributeError:
                    if handle.config_path.exists():
                        handle.config_path.unlink()
            self._handles.clear()

    def status(self) -> dict:
        with self._lock:
            return {
                endpoint_id: {
                    "alive": handle.is_alive(),
                    "config": str(handle.config_path),
                }
                for endpoint_id, handle in self._handles.items()
            }
